------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
-- WHERE절의 조건식에서 IN, LIKE 사용하기
-- WHERE 컬럼명 IN (값1, 값2, 값3, ...)
-- * 지정된 컬럼의 값이 값1 혹은 값2 혹은 값3 중의 하나와 일치하면 TRUE로 판정한다.
-- * WHERE 컬럼명 = 값1 OR 컬럼명 = 값2 OR 컬럼명 = 값3; 과 연산결과가 같다.

-- WHERE 컬럼명 LIKE '패턴'
-- * 지정된 컬럼의 값이 패턴과 일치하면 TRUE로 판정한다.
-- * 패턴 기호 (두 가지를 섞어서 사용해도 된다.)
--          % : ALL'
--              WHERE BOOK_TITLE LIKE '자바%';    책 제목이 '자바', '자바11', '자바 혼자서 공부하기'
--              WHERE BOOK_TITLE LIKE '%자바%';   책 제목이 '자바', '혼자서 공부하는 자바', '자바의 정석'
--              %자리에 무엇이든 올 수 있고, 아무것도 오지 않아도 된다.
--          _ : ANYONE
--              WHERE USER_NAME LIKE '이_';      사용자명이 '이이', '이상' 등 이씨중에서 이름이 한글자인 사람을 조회하는 것
--              _자리에 한자리인 글자가 꼭 와야 한다.
-- * % 기호를 패턴의 앞에 적는 것은 쿼리의 속도를 낮추므로 추천하지 않는다.
------------------------------------------------------------------------------------------------------
-- 직원 중에서 60번 부서와 90번 부서에서 근무중인 사원의 아이디, 이름, 직종아이디를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (60,90);

-- 부서 소재지의 국가아이디가 'US', 'FR'인 곳의 소재지 아이디, 주소, 도시명을 조회하기
SELECT LOCATION_ID, STREET_ADDRESS, CITY
FROM LOCATIONS
WHERE COUNTRY_ID IN ('US','FR');

-- 직원 중에서 50번 부서와 80번 부서에 근무중이며 급여를 5000 이상 10000 이하로 받은 사원의 아이디, 이름, 급여, 부서아이디를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (50,80) 
        AND SALARY BETWEEN 5000 AND 10000;

-- 직원들이 맡고 있는 직종 아이디가 'FI'로 시작하는 사원의 아이디, 이름, 직종아이디를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID LIKE 'FI%';

-- 직원들이 이름 중에서 영문자 'e'가 포함된 직원의 이름을 조회하기 '***e' 'e***' '**e****'
SELECT FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%e%';

-- 직원들 이름 중에서 영문자 'e'가 이름의 중간에 포함된 직원의 이름 조회하기 '**e****' '*e*' '***e***'
SELECT FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%_e_%';      -- '_%e%_'와 차이 없는지?
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
-- WHERE절의 조건에서 컬럼의 값이 NULL이거나 NULL 아닌 값 조회하기
-- * 데이터베이스에서 특정 컬럼의 값이 NULL이라는 것은 "그 컬럼의 값이 아직 결정되지 않았다"라는 의미다.
-- * 컬럼의 값이 NULL일 때는 비교(> >= < <= = !=)연산을 수행할 수 없다.
-- * 컬럼의 값이 NULL일 때는 NULL인 컬럼의 값과 사칙연산(+ - * /)을 수행하면 그 결과는 무조건 NULL이다.
-- * 데이터베이스에서의 NULL은 자바에서처럼 참조주소가 없는 값이 아니라, 아예 값이 결정되지 않은 것이다.

-- * 따라서 NULL 여부에 대한 조건문은 키워드가 따로 있다.
-- WHERE 컬럼 IS NULL;        해당 컬럼의 값이 NULL일 때 TRUE로 판정한다.
-- WHERE 컬럼 IS NOT NULL;    해당 컬럼의 값이 NULL이 아닐 때 TRUE로 판정한다.

------------------------------------------------------------------------------------------------------
-- 부서테이블에서 MANAGER_ID가 NULL인 부서의 부서아이디, 부서명 조회하기
SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS
WHERE MANAGER_ID IS NULL; -- MANAGER_ID = NULL; 이 아니다.

-- 부서 테이블에서 관리자가 지정된 부서의 부서아이디, 부서명, 관리자 아이디를 조회하기
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID
FROM DEPARTMENTS
WHERE MANAGER_ID IS NOT NULL;

-- 사원 테이블에서 소속부서가 아직 결정되지 않은 사원의 아이디, 이름, 직종아이디를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL;

------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
-- 조회된 행을 정렬하기
-- * ORDER BY절을 사용해서 조회된 행을 정렬할 수 있다.
-- * ORDER BY절을 사용하지 않을 경우 순서에 대한 보장 없이 조회한다. 꼭 기본 테이블의 행순서대로 나오는 것도 아니다.(DB의 테이블에서는 행의 순서가 중요하지 않다.)
-- * 따라서 여러 건 조회 시 항상 정렬할 것

-- SELECT 컬럼명, 컬럼명, 컬럼명
--      FROM 테이블명
--      WHERE 조건식
--      ORDER BY 정렬기준, 정렬기준; (정렬기준은 1개 이상 적을 수 있으나, 많을 수록 쿼리 속도 떨어지므로 최대 2개 권장)

-- * 정렬 기준은 아래와 같이 작성한다.
--      ORDER BY 컬럼명 또는 표현식             지정된 컬럼명의 값을 기준으로 오름차순 정렬
--      ORDER BY 컬럼명 또는 표현식             지정된 컬럼명의 값을 기준으로 오름차순 정렬
--      ORDER BY 컬럼명 또는 표현식 DESC        지정된 컬럼명의 값을 기준으로 내림차순 정렬


-- * ORDER BY 절은 SELECT문의 맨 끝에 위치해야 한다.
-- * ORDER BY 절에서는 SELECT문에서 지정한 별칭을 사용할 수 있다.
-- * WHERE 절에서는 SELECT문에서 지정한 별칭을 사용할 수 없다.
-- * ORDER BY 절에서는 컬럼명 대신 컬럼 순서를 나타내는 숫자를 사용해서 정렬할 수 있다.
--       SELECT ID, NAME, PRICE
--       FROM PRODUCTS
--       ORDER BY 3 DESC;       SELECT문의 3번째 컬럼인 PRICE가 정렬기준이 된다.

-- * 정렬 시 NULL값은 기본적으로 오름차순에서 가장 마지막, 내림차순에서 가장 처음 순서에 있다.
------------------------------------------------------------------------------------------------------
-- 80번 부서에서 일하는 사원들 중에서 급여를 5000 이상 10000 이하로 받는 사원들의 아이디, 이름, 직종아이디, 급여를 조회하기
-- 조회된 결과는 급여에 대한 오름차순으로 정렬하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80
ORDER BY SALARY;

-- 모든 사원들에 대해서 부서아이디로 오름차순 정렬하기, 사원아이디, 사원이름, 부서아이디를 조회한다.
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID ASC;

-- 50번 부서와 80번 부서에 소속된 사원들의 부서아이디, 급여, 이름을 조회하기
-- 부서아이디를 기준으로 오름차순으로 정렬하고, 부서아이디가 동일한 경우 급여 기준으로 내림차순으로 정렬한다.
SELECT DEPARTMENT_ID, SALARY, FIRST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (50,80)
ORDER BY 1, 2 DESC;
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
-- DISTINCT 키워드를 사용해서 중복된 행을 제거하기
-- SELECT DISTINCT 컬럼명, 컬럼명
-- FROM 테이블명;

-- * DISTINCT 키워드는 SELECT문에서 나열한 모든 컬럼의 값이 서로 같은, 중복행을 한번만 선택한다.
------------------------------------------------------------------------------------------------------
-- 직원들이 다양한 직종에서 일하고 있다. 직원들이 종사하고 있는 직종아이디를 중복없이 조회하기
SELECT DISTINCT JOB_ID, DEPARTMENT_ID 
FROM EMPLOYEES;

-- 소재지 정보를 참고해서 부서가 위치한 국가를 중복없이 조회하기
SELECT DISTINCT COUNTRY_ID
FROM LOCATIONS;

