-- 모든 직원의 아이디, 이름, 부서번호, 부서명을 조회하기(부서아이디가 NULL인 직원제외)
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID IS NOT NULL
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY EMPLOYEE_ID;

-- 커미션을 받는 직원들의 아이디, 이름, 부서번호, 부서명, 급여등급을 조회하기
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME, S.GRADE
FROM EMPLOYEES E, DEPARTMENTS D, SALARY_GRADE S
WHERE E.COMMISSION_PCT IS NOT NULL
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.SALARY >= S.MIN_SALARY AND E.SALARY <= S.MAX_SALARY
ORDER BY E.EMPLOYEE_ID;

-- 모든 직원의 직원아이디, 이름, 그 직원의 상사이름, 소속부서이름, 소속부서 관리자 이름 조회하기
--                 E1     E1          E2         D               D = E3
-- * EMPLOYEES의 MANAGER는 직원의 상사, DEPARTMENTS의 MANAGER는 부서의 관리자로 아예 다른 의미이다.
SELECT E.EMPLOYEE_ID EMP_ID, E.FIRST_NAME EMP_NAME, EM.FIRST_NAME EMP_M_NAME, D.DEPARTMENT_NAME DEPT_NAME, DM.FIRST_NAME DEPT_M_NAME
FROM EMPLOYEES E, EMPLOYEES EM, EMPLOYEES DM, DEPARTMENTS D
WHERE E.MANAGER_ID = EM.EMPLOYEE_ID
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID (+) -- 소속부서가 없는 경우에 대한 포괄조인
AND D.MANAGER_ID = DM.EMPLOYEE_ID (+)
ORDER BY E.EMPLOYEE_ID;
-- * 조인이 최선인가? 서브쿼리로 상사이름, 부서이름, 관리자이름 컬럼을 만들 수는 없다. 모두 새 테이블과 조인되어야 한다. 최선인듯.

-- 80번 부서의 평균급여, 최저급여, 최고급여를 조회하기
SELECT TRUNC(AVG(SALARY)), MIN(SALARY), MAX(SALARY) 
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

-- 각 부서별 최저급여와 최고급여, 그 둘 사이의 차이를 조회하기
SELECT MIN(SALARY) MIN_SAL, MAX(SALARY) MAX_SAL, MAX(SALARY) - MIN(SALARY) GAP_SAL
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL -- 해주지 않으면 DEPARTMENT가 NULL인 경우를 그룹으로 묶어 계산한다.
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

-- 100번 직원에게 보고하는 직원이 몇명인지 조회하기
SELECT COUNT(*)     -- 행그룹에서 모든 행의 개수를 반환한다.
FROM EMPLOYEES
WHERE MANAGER_ID = 100; -- 여기서 행그룹은 행 전체이다.

-- 부서별 최고급여를 조회했을 때 최고급여가 15000을 넘는 부서의 아이디와 최고급여를 조회하기
-- * 최고급여 15000 이상은 그룹함수 실행결과에 대한 필터조건이다. (WITH함수로 WHERE에서 필터조건 쓸 없다.)
SELECT DEPARTMENT_ID, MAX(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY) > 15000;

-- 직종별로 종사하는 직원수를 조회하고, 직원수로 오름차순 정렬해서 조회하기
SELECT JOB_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY COUNT(*);

-- first_name이 'Neena'인 직원보다 보다 많은 급여를 받는 직원의 아이디, 이름, 급여를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY
                FROM EMPLOYEES
                WHERE FIRST_NAME = 'Neena')
ORDER BY EMPLOYEE_ID;

-- 200번 직원과 같은 부서에서 근무하는 직원의 아이디, 이름, 급여를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                       FROM EMPLOYEES
                       WHERE EMPLOYEE_ID = 200)
ORDER BY EMPLOYEE_ID;

-- 직종별 평균급여를 계산했을 때 평균급여가 가장 적은 직종과 평균급여를 조회하기
WITH AVERAGES
AS (SELECT JOB_ID, AVG(SALARY) AVG
      FROM EMPLOYEES
      GROUP BY JOB_ID)
SELECT JOB_ID, AVG
FROM AVERAGES
WHERE AVG = (SELECT MIN(AVG)
            FROM AVERAGES);

-- 직종별 평균급여를 계산했을 때 평균급여가 가장 적은 직종의 아이디, 직종제목, 그 직종의 최저급여, 그 직종의 최대급여를 조회하기
WITH AVERAGES
    AS (SELECT JOB_ID, AVG(SALARY) AVG
       FROM EMPLOYEES
       GROUP BY JOB_ID)
SELECT A.JOB_ID, J.JOB_TITLE, J.MIN_SALARY, J.MAX_SALARY
FROM AVERAGES A, JOBS J
WHERE A.AVG = (SELECT MIN(AVG)
            FROM AVERAGES)
AND A.JOB_ID = J.JOB_ID;

-- 급여가 전체 직원의 평균급여보다 많이 받는 직원의 아이디, 이름, 급여를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY)
                FROM EMPLOYEES)
ORDER BY EMPLOYEE_ID;

--  'Neena'와 같은 해에 입사한 직원의 아이디, 이름, 입사일을 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = (SELECT TO_CHAR(HIRE_DATE, 'YYYY')
                                    FROM EMPLOYEES
                                    WHERE FIRST_NAME = 'Neena')
ORDER BY EMPLOYEE_ID;

-- 부서별 평균급여를 계산했을 때 Ismael이 근무하는 부서의 평균급여보다 급여를 많이 받는 부서의 아이디와 평균급여를 조회하기
WITH AVERAGES
    AS (SELECT DEPARTMENT_ID, AVG(SALARY) AVG
        FROM EMPLOYEES
        WHERE DEPARTMENT_ID IS NOT NULL
        GROUP BY DEPARTMENT_ID)
SELECT A.DEPARTMENT_ID, TRUNC(A.AVG) AVERAGE
FROM AVERAGES A, AVERAGES I, EMPLOYEES E
WHERE E.FIRST_NAME = 'Ismael'
AND E.DEPARTMENT_ID = I.DEPARTMENT_ID
AND A.AVG > I.AVG;

-- 직원 테이블의 급여를 기준으로 급여 등급을 조회했을 때, 급여등급별 직원수를 조회하기
SELECT Y.GRADE, NVL(GRADE_CNT,0)
FROM (SELECT S.GRADE, COUNT(*) GRADE_CNT
      FROM EMPLOYEES E, SALARY_GRADE S
      WHERE E.SALARY >= S.MIN_SALARY AND E.SALARY <= S.MAX_SALARY
      GROUP BY S.GRADE) X, SALARY_GRADE Y
WHERE X.GRADE (+) = Y.GRADE
ORDER BY Y.GRADE;

-- 직원들이 근무하는 부서의 소재도시와 그 도시에서 근무하는 직원수를 조회하기
SELECT L.CITY, COUNT(*) CITY_CNT
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
GROUP BY L.CITY 
ORDER BY L.CITY;

-- 가장 적은 직원이 입사한 해와 그 해에 입사한 직원수를 조회하기
WITH COUNTS
    AS (SELECT TO_CHAR(HIRE_DATE, 'YYYY') HIRE_YEAR, COUNT(*) CNT
        FROM EMPLOYEES
        GROUP BY TO_CHAR(HIRE_DATE, 'YYYY'))
SELECT HIRE_YEAR, CNT
FROM COUNTS
WHERE CNT = (SELECT MIN(CNT)
            FROM COUNTS);

-- 관리자별 직원수를 조회했을 때 직원수가 10명을 넘는 관리자 아이디와 직원수를 조회하기
SELECT MANAGER_ID, COUNT(*) EMP_CNT
FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING COUNT(*) > 10
ORDER BY MANAGER_ID;

-- 부서별 평균급여를 조회했을 때 그 부서의 평균급여보다 적은 급여를 받은 직원의 이름, 급여, 부서명을 조회하기 (부서명순으로 정렬하기)
SELECT E.FIRST_NAME, E.SALARY, E.DEPARTMENT_ID
FROM (SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY)) AVG
      FROM EMPLOYEES
      WHERE DEPARTMENT_ID IS NOT NULL
      GROUP BY DEPARTMENT_ID) A, EMPLOYEES E
WHERE E.DEPARTMENT_ID = A.DEPARTMENT_ID
AND E.SALARY < A.AVG
ORDER BY E.DEPARTMENT_ID;

-- employees 테이블에서 직원들의 모든 직종아이디를 조회하기
SELECT DISTINCT JOB_ID
FROM EMPLOYEES
ORDER BY JOB_ID;

-- 급여를 12,000달러 이상 받는 직원의 이름과 급여를 조회하기
SELECT EMPLOYEE_ID, SALARY
FROM EMPLOYEES
WHERE SALARY >= 12000
ORDER BY EMPLOYEE_ID;

-- 직원번호가 176번 직원의 아이디와 이름 직종을 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 176;

-- 급여를 12,000달러 이상 15,000달러 이하 받는 직원들의 직원 아이디와 이름과 급여를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 12000 AND 15000
ORDER BY EMPLOYEE_ID;

-- 2005년 1월 1일부터 2000년 6월 30일 사이에 입사한 직원의 아이디, 이름, 직종아이디, 입사일을 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '2000-06-30' AND '2005-01-01'  
ORDER BY HIRE_DATE;

-- 급여가 5,000달러와 12,000달러 사이이고, 부서번호가 20 또는 50인 직원의 이름과 급여를 조회하기
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 5000 AND 12000
AND DEPARTMENT_ID IN (20, 50)
ORDER BY EMPLOYEE_ID;

-- 관리자가 없는 직원의 이름과 직종아이디를 조회하기
SELECT FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;

-- 커미션을 받는 모든 직원의 이름과 급여, 커미션을 조회하고,  급여 및 커미션의 내림차순으로 정렬해서 조회하기
SELECT FIRST_NAME, SALARY, COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL
ORDER BY SALARY DESC, COMMISSION_PCT DESC;

-- 이름의 2번째 글자가 'e'인 모든 직원의 이름을 조회하기
SELECT FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_e%';

-- 직종아이디가 'ST_CLERK' 또는 'SA_REP'이고 급여를 2500, 3500, 7,000 받는 모든 직원의 이름과 직종아이디, 급여를 조회하기
SELECT FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE JOB_ID IN ('ST_CLERK', 'SA_REP')
AND SALARY IN (2500, 3500, 7000)
ORDER BY EMPLOYEE_ID;

-- 모든 직원의 이름과 입사일, 근무 개월 수를 계산하여 조회하기, 근무개월 수는 정수로 반올림하고, 근무개월수를 기준으로 오름차순으로 정렬하기
SELECT FIRST_NAME, HIRE_DATE, TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) WORK_MONTHS
FROM EMPLOYEES
ORDER BY WORK_MONTHS;

-- 직원의 이름과 커미션을 조회하기, 커미션을 받지 않는 직원은 '없음'으로 표시하기
SELECT FIRST_NAME, NVL(TO_CHAR(COMMISSION_PCT,'0.99'), '없음')
FROM EMPLOYEES;

-- 모든 직원의 이름, 부서번호, 부서이름을 조회하기
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.EMPLOYEE_ID;

-- EMPLOYEES 테이블에서 직원의 이름과 급여를 표시하고, 급여에 대해서 #로 표시하기. '#'하나는 급여 1000에 해당한다.
-- 출력예시
-- 홍길동 4300 ####
-- 김유신 8700 ########
-- 강감찬 6500 ######
SELECT FIRST_NAME, SALARY, RPAD('#',TRUNC(SALARY/1000),'#') SALARY#
FROM EMPLOYEES
ORDER BY EMPLOYEE_ID;

-- EMPLOYEES 테이블에서 2006년 상반기에 입사한 직원들의 직원아이디, 이름, 입사일, 연봉을 계산하기. 연봉은 급여12 + 급여커미션*12다.
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, TRUNC((SALARY+NVL(COMMISSION_PCT,0))*12) ANNUAL_SAL
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '2006-01-01' AND '2006-06-30'
ORDER BY EMPLOYEE_ID;

-- 80번부서에 소속된 직원의 이름과 직종아이디, 직종제목, 부서이름을 조회하기
SELECT E.FIRST_NAME, E.JOB_ID, J.JOB_TITLE, D.DEPARTMENT_NAME
FROM EMPLOYEES E, JOBS J, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = 80
AND E.JOB_ID = J.JOB_ID
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY EMPLOYEE_ID;

-- 커미션을 받는 모든 직원의 이름과 직종아이디, 직종제목, 부서이름, 부서소재지 도시명을 조회하기
SELECT E.FIRST_NAME, J.JOB_ID, J.JOB_TITLE, D.DEPARTMENT_NAME, L.CITY 
FROM EMPLOYEES E, JOBS J, DEPARTMENTS D, LOCATIONS L
WHERE COMMISSION_PCT IS NOT NULL
AND E.JOB_ID = J.JOB_ID
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
ORDER BY EMPLOYEE_ID;

-- 'Europe'에 소재지를 두고 있는 모든 부서아이디와 부서이름을 조회하기
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM DEPARTMENTS D, LOCATIONS L, COUNTRIES C, REGIONS R
WHERE R.REGION_NAME = 'Europe'
AND C.REGION_ID = R.REGION_ID
AND L.COUNTRY_ID = C.COUNTRY_ID
AND D.LOCATION_ID = L.LOCATION_ID;

-- 직원의 이름과 소속부서명, 급여, 급여 등급을 조회하기
SELECT E.FIRST_NAME, D.DEPARTMENT_NAME, E.SALARY, S.GRADE
FROM EMPLOYEES E, DEPARTMENTS D, SALARY_GRADE S
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID (+)
AND E.SALARY BETWEEN S.MIN_SALARY AND S.MAX_SALARY
ORDER BY DEPARTMENT_NAME;

-- 직원의 이름과 소속부서명, 소속부서의 관리자명을 조회하기, 소속부서가 없는 직원은 소속부서명 '없음', 관리자명 '없음'으로 표시하기
SELECT EMP.FIRST_NAME, NVL(D.DEPARTMENT_NAME, '없음') DEPT_NAME, NVL(MNG.FIRST_NAME, '없음') DEPT_MNG_NAME
FROM EMPLOYEES EMP, EMPLOYEES MNG, DEPARTMENTS D
WHERE EMP.DEPARTMENT_ID = D.DEPARTMENT_ID (+)
AND D.MANAGER_ID = MNG.EMPLOYEE_ID (+)
ORDER BY EMP.FIRST_NAME;

-- 모든 직원의 급여 최고액, 급여 최저액, 급여 총액, 급여 평균액을 조회하기
SELECT MAX(SALARY), MIN(SALARY), SUM(SALARY), TRUNC(AVG(SALARY))
FROM EMPLOYEES;

-- 직종별 급여 최고액, 급여 최저액, 급여 총액, 급여 평균액을 조회하기
SELECT JOB_ID, MAX(SALARY), MIN(SALARY), SUM(SALARY), TRUNC(AVG(SALARY))
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;

-- 각 직종별 직원수를 조회해서 가장 직원수가 많은 직종 3개를 조회하기, 직종아이디와 직원수 표시하기
SELECT JOB_ID, CNT
FROM (SELECT JOB_ID, COUNT(*) CNT
      FROM EMPLOYEES
      GROUP BY JOB_ID
      ORDER BY CNT DESC)
WHERE ROWNUM IN (1,2,3)
ORDER BY ROWNUM;

-- 관리자별 직원수를 조회하기, 관리자 이름과 그 관리자가 관리하는 직원수 표시하기
SELECT M.FIRST_NAME, COUNT(*) CNT
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID IS NOT NULL
AND E.MANAGER_ID = M.EMPLOYEE_ID
GROUP BY M.FIRST_NAME
ORDER BY CNT;

-- 각 부서에 대해 부서이름, 관리자 이름, 소속직원 수, 소속직원들의 평균 급여를 조회하기
SELECT D.DEPARTMENT_NAME, M.FIRST_NAME MNG_NAME, COUNT(*) EMP_CNT, TRUNC(AVG(E.SALARY)) EMP_SAL_AVG
FROM EMPLOYEES E, DEPARTMENTS D, EMPLOYEES M
WHERE E.DEPARTMENT_ID IS NOT NULL
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.MANAGER_ID = M.EMPLOYEE_ID
GROUP BY D.DEPARTMENT_NAME, M.FIRST_NAME
ORDER BY D.DEPARTMENT_NAME;

-- first_name이 'Steven'인 직원과 같은 부서에 속한 직원의 이름과 입사일을 조회하기
SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
                       FROM EMPLOYEES
                       WHERE FIRST_NAME = 'Steven')
ORDER BY HIRE_DATE;

-- 소속 부서의 평균급여보다 많은 급여를 받는 직원의 아이디와 직원이름, 급여, 그 부서의 평균 급여를 조회하기
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, A.AVG 
FROM (SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY)) AVG
      FROM EMPLOYEES
      GROUP BY DEPARTMENT_ID) A, EMPLOYEES E
WHERE E.DEPARTMENT_ID IS NOT NULL
AND E.DEPARTMENT_ID = A.DEPARTMENT_ID
AND E.SALARY > A.AVG
ORDER BY E.EMPLOYEE_ID;

-- first_name이 'Kochhar'과 직원과 동일한 급여를 받는 모든 직원의 이름, 입사일, 급여를 조회하기, 결과에 Kochhar은 포함시키지 않기
SELECT E.LAST_NAME, E.HIRE_DATE, E.SALARY
FROM EMPLOYEES E, EMPLOYEES K
WHERE K.LAST_NAME = 'Kochhar'
AND E.LAST_NAME != 'Kochhar'
AND E.SALARY IN K.SALARY;
-- * first_name이 'Korchhar'인 직원은 존재하지 않음.

-- 소속 부서에 입사일이 늦지만, 더 많은 급여를 받는 직원의 이름과 소속부서명, 급여를 조회하기
SELECT DISTINCT E1.FIRST_NAME, D.DEPARTMENT_NAME, E1.SALARY
FROM EMPLOYEES E1, EMPLOYEES E2, DEPARTMENTS D
WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID
AND E1.HIRE_DATE > E2.HIRE_DATE
AND E1.SALARY > E2.SALARY
AND D.DEPARTMENT_ID = E1.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_NAME;

-- 관리자 아이디, 관리자명, 그 관리자가 관리하는 직원수, 그 관리자가 소속된 부서를 조회하기
SELECT M.EMPLOYEE_ID, M.FIRST_NAME, COUNT(*) EMP_CNT, M.DEPARTMENT_ID 
FROM EMPLOYEES M, EMPLOYEES E
WHERE M.EMPLOYEE_ID = E.MANAGER_ID
GROUP BY M.EMPLOYEE_ID, M.FIRST_NAME, M.DEPARTMENT_ID
ORDER BY M.DEPARTMENT_ID, M.EMPLOYEE_ID;